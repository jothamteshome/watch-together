name: Deploy backend to EC2 via AWS SSM

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:


    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1


    - name: Assign temporary public IPv4 to EC2 instance
      id: assign-ip
      run: |
        # Allocate Elastic IP
        ALLOCATION_ID=$(aws ec2 allocate-address --domain vpc --query 'AllocationId' --output text)

        # Associate with instance
        aws ec2 associate-address \
          --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
          --allocation-id $ALLOCATION_ID


    - name: Wait for SSM agent to reconnect
      run: |
        echo "⏳ Waiting for SSM agent to reconnect..."

        INSTANCE_ID=${{ secrets.EC2_INSTANCE_ID }}
        MAX_ATTEMPTS=24
        ATTEMPT=1

        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking SSM connectivity..."
          
          # Check PingStatus
          STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query 'InstanceInformationList[0].PingStatus' \
            --output text 2>/dev/null || echo "null")
          
          if [ "$STATUS" = "Online" ]; then
            echo "✅ SSM agent is online!"

            # Optional: run a small test command
            TEST_COMMAND_ID=$(aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters '{"commands":["echo SSM_TEST_SUCCESS"]}' \
              --query 'Command.CommandId' \
              --output text)

            # Wait for the test command to succeed
            MAX_TEST_ATTEMPTS=6
            TEST_ATTEMPT=1
            while [ $TEST_ATTEMPT -le $MAX_TEST_ATTEMPTS ]; do
              TEST_STATUS=$(aws ssm list-command-invocations \
                --command-id $TEST_COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query "CommandInvocations[0].Status" \
                --output text 2>/dev/null || echo "null")

              if [ "$TEST_STATUS" = "Success" ]; then
                echo "✅ SSM test command successful!"
                exit 0
              elif [ "$TEST_STATUS" = "Failed" ]; then
                echo "❌ SSM test command failed. Retrying outer loop..."
                break
              fi

              echo "Test command status: $TEST_STATUS ($TEST_ATTEMPT/$MAX_TEST_ATTEMPTS)"
              sleep 5
              TEST_ATTEMPT=$((TEST_ATTEMPT + 1))
            done

            echo "⚠️ SSM test command did not succeed but agent is online. Proceeding..."
            exit 0
          else
            echo "SSM status: $STATUS (waiting...)"
          fi

          sleep 10
          ATTEMPT=$((ATTEMPT + 1))
        done

        echo "❌ SSM agent failed to come online within expected time."
        exit 1


    - name: Kill all tmux sessions
      run: |
        command_id=$(aws ssm send-command \
          --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands":["sudo -u ec2-user bash -c '\''tmux kill-server 2>/dev/null || true'\''"]}' \
          --comment "Kill old tmux sessions" \
          --query 'Command.CommandId' \
          --output text)
        echo "command_id=$command_id" >> $GITHUB_ENV

    
    - name: Wait for `Kill all tmux sessions` to complete
      run: |
        while true; do
          status=$(aws ssm list-command-invocations \
            --command-id ${{ env.command_id }} \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query "CommandInvocations[0].Status" \
            --output text)
          echo "Status: $status"
          if [[ "$status" == "Success" ]]; then
            break
          elif [[ "$status" == "Cancelled" || "$status" == "Failed" || "$status" == "TimedOut" ]]; then
            echo "Command failed with status: $status"
            exit 1
          fi
          sleep 5
        done


    - name: Pull latest code on EC2
      run: |
        command_id=$(aws ssm send-command \
          --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands":[
            "sudo -u ec2-user bash -c '\''mkdir -p /home/ec2-user/watch-together'\''",
            "sudo -u ec2-user bash -c '\''cd /home/ec2-user/watch-together && git config --global --add safe.directory /home/ec2-user/watch-together && git checkout main && git pull origin main'\''"
          ]}' \
          --comment "Update code" \
          --query 'Command.CommandId' \
          --output text)
        echo "command_id=$command_id" >> $GITHUB_ENV


    - name: Wait for `Pull latest code on EC2` to complete
      run: |
        while true; do
          status=$(aws ssm list-command-invocations \
            --command-id ${{ env.command_id }} \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query "CommandInvocations[0].Status" \
            --output text)
          echo "Status: $status"
          if [[ "$status" == "Success" ]]; then
            break
          elif [[ "$status" == "Cancelled" || "$status" == "Failed" || "$status" == "TimedOut" ]]; then
            echo "Command failed with status: $status"
            exit 1
          fi
          sleep 5
        done


    - name: Install dependencies & build
      run: |
        command_id=$(aws ssm send-command \
          --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands":[
            "sudo -u ec2-user bash -c '\''cd /home/ec2-user/watch-together/backend && npm install && npm run build'\''"
          ]}' \
          --comment "Install dependencies and build" \
          --query 'Command.CommandId' \
          --output text)
        echo "command_id=$command_id" >> $GITHUB_ENV

    
    - name: Wait for `Install dependencies & build` to complete
      run: |
        while true; do
          status=$(aws ssm list-command-invocations \
            --command-id ${{ env.command_id }} \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query "CommandInvocations[0].Status" \
            --output text)
          echo "Status: $status"
          if [[ "$status" == "Success" ]]; then
            break
          elif [[ "$status" == "Cancelled" || "$status" == "Failed" || "$status" == "TimedOut" ]]; then
            echo "Command failed with status: $status"
            exit 1
          fi
          sleep 5
        done

    
    - name: Start tmux session and run server
      run: |
        command_id=$(aws ssm send-command \
          --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands":[
            "sudo -u ec2-user bash -c '\''cd /home/ec2-user/watch-together/backend && tmux new-session -d -s watch-together-backend'\''",
            "sudo -u ec2-user bash -c '\''tmux send-keys -t watch-together-backend \"BACKEND_PORT=${{ secrets.BACKEND_PORT }} YOUTUBE_API_KEY=${{ secrets.YOUTUBE_API_KEY }} npm run start\" C-m'\''"
          ]}' \
          --comment "Start server in tmux" \
          --query 'Command.CommandId' \
          --output text)
        echo "command_id=$command_id" >> $GITHUB_ENV


    - name: Wait for `Start tmux session and run server` to complete
      run: |
        while true; do
          status=$(aws ssm list-command-invocations \
            --command-id ${{ env.command_id }} \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query "CommandInvocations[0].Status" \
            --output text)
          echo "Status: $status"
          if [[ "$status" == "Success" ]]; then
            break
          elif [[ "$status" == "Cancelled" || "$status" == "Failed" || "$status" == "TimedOut" ]]; then
            echo "Command failed with status: $status"
            exit 1
          fi
          sleep 5
        done


    - name: Remove temporary public IPv4
      if: always()
      run: |
        aws ec2 disassociate-address --association-id $ASSOCIATION_ID
        aws ec2 release-address --allocation-id $ALLOCATION_ID

